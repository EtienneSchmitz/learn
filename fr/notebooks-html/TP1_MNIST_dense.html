


  <div class="cell border-box-sizing text_cell rendered">
    <button class="js-nbinteract-widget">
      Show All Widgets
    </button></div>



<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Machine-learning-avec-les-modules-Python-tensorflow2/keras">Machine learning avec les modules Python tensorflow2/keras<a class="anchor-link" href="#Machine-learning-avec-les-modules-Python-tensorflow2/keras">&#182;</a></h1></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Entra&#238;nement-/-exploitation-d'un-r&#233;seau-de-neurones-dense-pour-la-reconnaissance-de-chiffres-manuscrits">Entra&#238;nement / exploitation d'un r&#233;seau de neurones dense pour la reconnaissance de chiffres manuscrits<a class="anchor-link" href="#Entra&#238;nement-/-exploitation-d'un-r&#233;seau-de-neurones-dense-pour-la-reconnaissance-de-chiffres-manuscrits">&#182;</a></h2></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="La-banque-d'images-MNIST">La banque d'images MNIST<a class="anchor-link" href="#La-banque-d'images-MNIST">&#182;</a></h2><p>Dans ce TP nous utilisons les images labelisées de la banque MNIST disponible sur Internet (<a href="http://yann.lecun.com/exdb/mnist/">http://yann.lecun.com/exdb/mnist/</a>).</p>
<p>La banque MNIST contient 70000 images en ton de gris de 28 $\times$ 28 pixels, correspondant à des matrice 28 $\times$ 28 de nombres <code>uint8</code> (entiers positifs dans l'intervalle [0 ; 255]).<br>
Les 70000 images du MNIST sont regoupées en un jeu de <strong>60000 images d'apprentissage</strong> et un jeu de <strong>10000 images de test</strong>.</p>
<p><div class="alert alert-block alert-danger">
L'évaluation des performances d'un réseau entraîné doit se faire sur un jeu de données différent du jeu d'entraînement : c'est pour cela que la banque MNIST propose 10000 images de test différentes des 60000 images d'entraînement.</div></p>
<p style="text-align:center; font-style:italic; font-size:12px;">
<img src="img/MnistExamples.png" width="500"><br>
[crédit image : Josef Steppan — commons.wikimedia.org/w/index.php?curid=64810040)]
</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="A/-Rappels-des-principaux-concepts...">A/ Rappels des principaux concepts...<a class="anchor-link" href="#A/-Rappels-des-principaux-concepts...">&#182;</a></h1><h2 id="Le-neurone-artificiel">Le neurone artificiel<a class="anchor-link" href="#Le-neurone-artificiel">&#182;</a></h2><p>C'est une unité de traitement informatique programmée pour calculer la valeur de sa <strong>fonction d'activation</strong> en un point défini par la <strong>combinaison linéaire de ses entrées</strong> $\sum_i \omega_i x_i - b$ :</p>
<p style="text-align:center; font-style:italic; font-size:12px;">
    <img src="./img/nn_1.png" width="600" ><br>
    [crédit image : JLC]
</p><p>L'entrée <em>Bias</em> reçoit le stimuli <code>-1</code> affecté du poids $b$ permettant de décaler le point où la fonction d'activation ets calculée.</p>
<h2 id="Fonction-d'activation">Fonction d'activation<a class="anchor-link" href="#Fonction-d'activation">&#182;</a></h2><p>Principaux rôles :</p>
<ul>
<li>introduire dans le neurone un comportement <strong>non linéaire</strong> (comme des mécanismes de seuil, de saturation...)</li>
<li>fixer la plage de sortie de la valeur calculée par le neurone, par exemple dans l'intervalle $[-1 ; 1]$, ou $[0 ; +\infty[$</li>
</ul>
<p>Exemples de fonctions d'activations couramment utilisées :<br /></p>
<p style="text-align:center; font-style:italic; font-size:12px;">
    <img src="./img/activationFunctions.png" width="950"><br>
    [crédit image : JLC]
</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="B/-Structure-du-r&#233;seau-dense-&#224;-construire">B/ Structure du r&#233;seau dense &#224; construire<a class="anchor-link" href="#B/-Structure-du-r&#233;seau-dense-&#224;-construire">&#182;</a></h1><p>Dans ce premier TP,  nous allons construire un <strong>réseau dense</strong>, avec :</p>
<ul>
<li>une <strong>couche d'entrée</strong> de 784 valeurs comprises entre 0 et 1 (les pixels des image MNIST 28 $\times$ 28 mis sous forme d'un vecteur de 784 nombres <code>float</code>),</li>
<li>une <strong>couche cachée</strong> de 784 neurones utilisant la fonction d'activation <code>relu</code>,</li>
<li>une <strong>couche de sortie</strong> à 10 neurones, pour la classification des images en 10 classes associées aux chiffres {0,1,2...9}, utilisant la fonction d'activation <code>softmax</code> adaptée aux problèmes de classification.</li>
</ul>
<p style="text-align:center; font-style:italic; font-size:12px;">
    <img src="img/archiReseau.png" alt="archiReseau.png" style="width: 900px;"><br> 
    [crédit image : JLC]
</p><p>Remarques :</p>
<ul>
<li>Chaque neurone de la première couche cachée reçoit 785 entrées : les 784 valeurs $x_i$ des pixels de l'image plus le biais (l'entrée '-1'). </li>
<li>$\leadsto$ Il y a donc 785 inconnues pour chaque neurone : les 784 poids $w_i$ affectés à chaque entrée $x_i$, plus le  poids $b$ affecté au biais.</li>
<li>$\leadsto$ on compte donc 785 $\times$ 784 inconnues pour la couche cachée et 785 $\times$ 10 inconnues pour la couche de sortie : soit un total de 623290 inconnues dont la valeur doit être optimisée par l'algorithme d'apprentissage du réseau.</li>
</ul>
<h3 id="Fonction-d'activation-softmax">Fonction d'activation softmax<a class="anchor-link" href="#Fonction-d'activation-softmax">&#182;</a></h3><p>La fonction <code>softmax</code> calcule pour chaque neurone de sortie $k$ la valeur $\displaystyle{Y_k = \frac{e^{y_k}}{\sum_i{e^{y_i}}}}$.</p>
<p><code>softmax</code> associe ainsi à chacune des sorties $y_k$ une valeur $Y_k \in [0, 1]$ qui peut être interprétée comme la probablité de la sortie $k$ : on obtient une valeur proche de 1 pour le neurone fournissant la valeur $y_i$ la plus grande, et quasiment 0 pour tous les autres.</p>
<p style="text-align:center; font-style:italic; font-size:12px;">
    <img src="img/softmax.png" width="400"><br>
    [crédit image : JLC]
</p><h3 id="Cat&#233;gorisation-des-labels-(one-hot-coding)">Cat&#233;gorisation des labels (<em>one-hot coding</em>)<a class="anchor-link" href="#Cat&#233;gorisation-des-labels-(one-hot-coding)">&#182;</a></h3><p>Les labels des images sont des entiers entre 0 et 9 désignant les chiffres de '0' à '9' alors que la sortie du réseau est un ensemble de 10 valeurs <code>float</code> comprises entre 0 et 1 (un vecteur de 10 <code>float</code>).<br>
Pour faciliter la comparaison entre le label associé à une image et la sortie du réseau calculée pour cette image, on utilise la catégorisation <em>one-hot coding</em> : chaque classe (label) est associée à un vecteur $Y'$ comportant autant d'éléments que de classes à reconnaître : les éléments du vecteur sont tous nuls sauf un, permettant d'identifier de façon unique chacune des classes.<br></p>
<p>Pour notre exemple des 10 classes correspondant aux labels '0' à '9' :</p>
<ul>
<li>le label <code>0</code> correspond au vecteur $Y'_1 = [1 0 0 0 0 0 0 0 0 0]$.</li>
<li>le label <code>3</code> correspond au vecteur $Y'_4 = [0 0 0 1 0 0 0 0 0 0]$.</li>
<li>le label <code>9</code> correspond au vecteur $Y'_9 = [0 0 0 0 0 0 0 0 0 1]$.</li>
</ul>
<h3 id="Calcul-de-l'erreur">Calcul de l'erreur<a class="anchor-link" href="#Calcul-de-l'erreur">&#182;</a></h3><p>Pendant la phase d'entraînement du réseau, chaque image en entrée du réseau donne un vecteur de probabilités en sortie (réponse calculée par le réseau) qui peut doit être comparé à la représentation <em>hot-one</em> du label associé à l'image d'entrée.</p>
<p>On peut utiliser l'erreur <em>cross entropy</em>  ($-\sum_i{Y'_i.\log{Y_i}}$) qui mesure l'écart entre la représentation <em>one-hot</em> du label et la réponse du réseau :</p>
<p style="text-align:center; font-style:italic; font-size:12px;">
    <img src="img/CrossEntropy.png" width=600><br>
    [crédit image : vidéo "Deep Learning TensorFlow" de Martin Gorner]
</p><h3 id="Backpropagation-error">Backpropagation error<a class="anchor-link" href="#Backpropagation-error">&#182;</a></h3><p>L'algorithme de <strong>retropropagation de l'erreur</strong> permet de modifier les poids des couches du réseau pour minimiser l'erreur entre valeur attendue et valeur prédite par le réseau. <br>
Au fur et à mesure des apprentissages successifs, les poids du réseau convergent vers un état qui constitue le réseau entraîné.</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Reproductibilit&#233;-des-g&#233;n&#233;rateurs-pseudo-al&#233;atoires">Reproductibilit&#233; des g&#233;n&#233;rateurs pseudo-al&#233;atoires<a class="anchor-link" href="#Reproductibilit&#233;-des-g&#233;n&#233;rateurs-pseudo-al&#233;atoires">&#182;</a></h3></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Les poids d'un réseau de neurones sont initialisés par tirage aléatoire ; lorsqu'on invoque plusieurs fois de suite des générateurs pseudo-aléatoires (comme <code>numpy.random.rand</code>...) on constate qu'à chaque invocation, on obtient une suite de valeurs aléatoires différentes :</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Ce comportement peut être source de problèmes pour l'étude des performances d'un réseau entraîné en fonction des paramètres de construction ou d'entraînement : à chaque fois qu'on exécute la cellule ou le notebook avec de nouvelles valeurs des paramètres, on obtient un état initial du réseau différent, conduisant à un état du réseau entraîné différent... ce qui peut gêner les comparaisons.</p>
<p>Pour éviter ce phénomène, on peut fixer la <strong>graine</strong> (<em>seed</em>) des générateurs aléatoires de façon à produire des séquences de nombres aléatoires <strong>reproductibles</strong>.<br></p>
<p>Les cellules suivantes illustrent le mécanisme :</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">SEED</span> <span class="o">=</span> <span class="mi">43</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">SEED</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">SEED</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Pour appliquer ce mécanisme aux calculs fait avec tensorflow, on pourra utiliser la fonction <code>set_seed</code> (cf page <a href="https://www.tensorflow.org/api_docs/python/tf/random/set_seed">tf.random.set_seed</a>) :
<strong><code>tf.random.set_seed(SEED)</code></strong></p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="C/-Travail-&#224;-faire">C/ Travail &#224; faire<a class="anchor-link" href="#C/-Travail-&#224;-faire">&#182;</a></h1></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Environnement-Python-de-travail">Environnement Python de travail<a class="anchor-link" href="#Environnement-Python-de-travail">&#182;</a></h2></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<div class="alert alert-block alert-danger">
<span style="color:brown;font-family:arial;font-size:normal"> 
L'état de l'art actuel des projets de machine learning sous Python préconise l'utilisation d'un <span style="font-weight:bold;">environnement virtuel Python</span> qui permet de maîtriser pour chaque projet les versions des modules Python "sensibles" (comme tensorflow par exemple).

Dans le cas d'un démarrage de l'ordinateur avec une clef USB Ubuntu, on peut considérer que la clef fournit un environnement Python dédié, à condition de ne pas faire de mises à jour des paquets Python avec <span style="font-style:italic">pip install...</span>

Dans le cas contraire, la <A href="https://learn.ros4.pro/fr/faq/Python/">FAQ Python</A> explique comment créer et utiliser un EVP pour utiliser |numpy` et `tensorflow2` avec la bibliothèque optimisée <A href="https://software.intel.com/content/www/us/en/develop/tools/oneapi/components/onemkl.html">MKL</A>.
</span></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Documentation-tensorflow/keras">Documentation tensorflow/keras<a class="anchor-link" href="#Documentation-tensorflow/keras">&#182;</a></h3><p>Le module <strong>keras</strong> qui permet une manipulation de haut niveau des objets <strong>tensorflow</strong> est intégré dans tensorflow2. <br>
La documentation du module <strong>tf.keras</strong> à consulter pour ce TP est ici : <a href="https://www.tensorflow.org/api_docs/python/tf/keras">https://www.tensorflow.org/api_docs/python/tf/keras</a>.</p>
<p>Versions des modules Python validées pour ce TP sous Ubuntu 20 / Python3.8.5 :</p>
<ul>
<li>tensorflow 2.4.0 incluant tensorflow.keras 2.4.0</li>
<li>OpenCV 4.2.0</li>
</ul></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">from</span> <span class="nn">tensorflow</span> <span class="kn">import</span> <span class="n">keras</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">cv2</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Python    : </span><span class="si">{</span><span class="n">sys</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tensorflow: </span><span class="si">{</span><span class="n">tf</span><span class="o">.</span><span class="n">__version__</span><span class="si">}</span><span class="s2"> incluant keras </span><span class="si">{</span><span class="n">keras</span><span class="o">.</span><span class="n">__version__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;OpenCV    : </span><span class="si">{</span><span class="n">cv2</span><span class="o">.</span><span class="n">__version__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Incrustation des tracés matplotlib dans le cahier IPython et import de modules utiles :</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="1---R&#233;cup&#233;ration-des-images-MNIST">1 - R&#233;cup&#233;ration des images MNIST<a class="anchor-link" href="#1---R&#233;cup&#233;ration-des-images-MNIST">&#182;</a></h2></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Consulter la documentation de la fonction <code>load_data</code> sur la page <a href="https://www.tensorflow.org/api_docs/python/tf/keras/datasets/mnist/load_data">tf.keras.datasets.mnist.load_data</a> puis compléter la cellule ci-dessous pour charger les données du MNIST en nommant les données renvoyées :<br></p>
<ul>
<li><code>im_train</code>, <code>im_test</code> pour les images d'entraînement et de test,</li>
<li><code>lab_train</code>, <code>lab_test</code> pour les labels des données d'entraînement et de test.</li>
</ul></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>La cellule ci-dessous affiche les attributs <code>shape</code> et <code>dtype</code> des tableaux numpy obtenus : les valeurs sont-elles cohérentes ? pourquoi ?</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;im_train -&gt; shape:&quot;</span><span class="p">,</span> <span class="n">im_train</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;, dtype:&quot;</span><span class="p">,</span> <span class="n">im_train</span><span class="o">.</span><span class="n">dtype</span><span class="p">,)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;im_test  -&gt; shape:&quot;</span><span class="p">,</span> <span class="n">im_test</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>  <span class="s2">&quot;, dtype:&quot;</span><span class="p">,</span> <span class="n">im_test</span><span class="o">.</span><span class="n">dtype</span><span class="p">,)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;lab_train-&gt; shape:&quot;</span><span class="p">,</span> <span class="n">lab_train</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>  <span class="s2">&quot;, dtype:&quot;</span><span class="p">,</span> <span class="n">lab_train</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;lab_test -&gt; shape:&quot;</span><span class="p">,</span> <span class="n">lab_test</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>  <span class="s2">&quot;, dtype:&quot;</span><span class="p">,</span> <span class="n">lab_test</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Visualisation-des-images-et-des-&#233;tiquettes-:">Visualisation des images et des &#233;tiquettes :<a class="anchor-link" href="#Visualisation-des-images-et-des-&#233;tiquettes-:">&#182;</a></h3></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Avec la fonction <code>imshow</code> du module <code>matplotlib.pyplot</code> faire afficher en tons de gris la 601-ème image du tableau <code>im_train</code>.<br>
Indications :</p>
<ul>
<li>utiliser <code>plt.figure(figsize=(2,2))</code> pour fixer la taille de l'image</li>
<li>utiliser l'option <code>cmap='gray'</code> de <code>imshow</code> pour l'affichage en ton de gris</li>
<li>enlever les graduations en X et Y (par exemple avec : <code>plt.xticks([]); plt.yticks([])</code>).</li>
</ul></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Vérifier que le label MNIST associé à <code>image_train[600]</code> correspond bien à ce qu'on voir sur l'image....</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Écrire une fonction <code>plot_images</code> d'arguments <code>images, r, L, C</code> qui affiche les images du tableau <code>images</code> (tableau de matrices) dans une grille d'images de <code>L</code> lignes et <code>C</code> colonnes  en commençant avec l'image de rang <code>r</code>. La taille de la figure totale (option<code>figsize</code> de <code>plt.figure</code>) sera fixée pour que chaque image de la grille soit de taille <code>(1,1)</code>.<br>
<em>Indications</em> : utiliser <code>plt.subplot(L,C,n)</code> pour positionner la nième image dans la grille des L x C images.</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Faire afficher les images d'entraînement à partir de la 601 ème dans une grille de 4 x 6 :</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Bonus</strong> : trier les images <code>im_train</code> pour faire afficher le même type d'image que celle figurant en tout début du notebook (des 0,1...9 en noir sur fond blanc sur 16 colonnes)...</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Pr&#233;-traitement-des-donn&#233;es-MNIST">Pr&#233;-traitement des donn&#233;es MNIST<a class="anchor-link" href="#Pr&#233;-traitement-des-donn&#233;es-MNIST">&#182;</a></h3></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Pour adapter les données à la couche d'entrée du réseau de neurones, on transforme les matrice d'entiers <code>uint8</code> représentant les images 28x28 pixels en vecteurs <strong>normalisés</strong> $(V_i)_{i=0..783}$ de 784 valeurs réelles $V_i$  avec $ 0 \leqslant V_i \leqslant 1$.</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Transformation-des-matrices-d'entr&#233;e-en-vecteurs-normalis&#233;s-:">Transformation des matrices d'entr&#233;e en vecteurs normalis&#233;s :<a class="anchor-link" href="#Transformation-des-matrices-d'entr&#233;e-en-vecteurs-normalis&#233;s-:">&#182;</a></h3></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Pour paramétrer les traitements, on récupère à l'aide des tableaux <code>im_train</code> et <code>im_test</code> :</p>
<ul>
<li>le nombre d'images d'entraînement (<code>nb_im_train</code> et <code>nb_im_test</code>)</li>
<li>le nombre de pixels des images (<code>nb_pixel</code>)</li>
</ul></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># compléter la cellule...</span>
<span class="n">nb_im_train</span> <span class="o">=</span> 
<span class="n">nb_im_test</span>  <span class="o">=</span> 
<span class="n">nb_pixel</span>    <span class="o">=</span>      
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Vérification :</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nb_im_train</span><span class="si">}</span><span class="s2"> images d&#39;entraînement et </span><span class="si">{</span><span class="n">nb_im_test</span><span class="si">}</span><span class="s2"> images de test&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nb_pixel</span><span class="si">}</span><span class="s2"> pixels dans chaque image&quot;</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Définir maintenant les tableaux <code>x_train</code> et <code>y_train</code> contenant les matrices des tableaux <code>im_train</code> et <code>im_test</code> <em>mises à plat</em> sous forme de vecteurs normalisés (valeurs comprises entre 0 et 1).<br>
<em>indications</em> : utiliser la méthode <code>reshape</code> des tableaux ndarray de numpy et les valeurs des paramètres <code>nb_im_train</code>, <code>nb_im_test</code> et <code>nb_pixel</code> calulés précédemment :</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Vérifier visuellement que les dimensions des tableaux <code>x_train</code> et <code>x_test</code> sont bien celles attendues :</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Vérifier que les valeurs min et max des tableaux <code>x_train</code> et <code>x_test</code> sont bien celles attendues :</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Codage-one-hot--des-labels:">Codage <em>one-hot</em>  des labels:<a class="anchor-link" href="#Codage-one-hot--des-labels:">&#182;</a></h3></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Consulter la documentation de la fonction <code>to_categorical</code> sur la page <a href="https://www.tensorflow.org/api_docs/python/tf/keras/utils/to_categorical">tf.keras.utils.to_categorical</a>  et en déduire comment définir les tableaux <code>y_train</code> et <code>y_test</code> contenant la version encodée <em>hot-one</em> des tableaux <code>lab_train</code> et <code>lab_test</code> :</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Vérifier visuellement les 10 premières valeurs des tableaux <code>lab_train</code> et <code>y_train</code> :</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="3---Construction-du-r&#233;seau-de-neurones">3 - Construction du r&#233;seau de neurones<a class="anchor-link" href="#3---Construction-du-r&#233;seau-de-neurones">&#182;</a></h2></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>On va maintenant construire un réseau de neurones <strong>séquentiel</strong> en <strong>4 lignes</strong> Python à l'aide du module <strong>keras</strong>.</p>
<p>Après lecture de la page <a href="https://www.tensorflow.org/guide/keras/sequential_model">guide/keras/sequential_model</a>, construire le réseau  de façon incrémentale avec la méthode <code>add</code> dans la cellule ci-dessous en suivant la démarche proposée :</p>
<ul>
<li>1/ Créer l'objet <code>model</code> instance de la classe <code>Sequential</code> (cf <a href="https://www.tensorflow.org/api_docs/python/tf/keras/Sequential">tf.keras.Sequential</a>).</li>
<li>2/ Les couches du réseau sont des objets de type <code>Dense</code> ajoutés à <code>model</code> avec la méthode <code>add</code>. (cf <a href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Dense">tf.keras.layers.Dense</a>) <br>
Chaque objet <code>Dense</code> est construit avec les arguments propres à sa couche :<ul>
<li>couche 1 : <code>Dense(nb_pixel, input_shape=nb_pixel, activation='relu')</code><ul>
<li><code>nb_pixels</code> neurones dans la couche,</li>
<li><code>input_shape=(nb_pixel,)</code> : donne le nombre d'entrées (noter le tuple <code>(nb_pixel,)</code>)</li>
<li><code>activation='relu'</code> affecte la fonction d'activation <em>relu</em> à tous les neurones de la couche (cf  <a href="https://www.tensorflow.org/api_docs/python/tf/keras/activations/relu">tf.keras.activation.relu</a>).</li>
</ul>
</li>
<li>couche 2 : <code>Dense(nb_classes, activation='softmax')</code><ul>
<li><code>nb_classes</code> neurones dans le couche,</li>
<li><code>activation='softmax'</code> affecte la fontion d'activation <em>softmax</em> à tous les neurones de la couche (cf <a href="https://www.tensorflow.org/api_docs/python/tf/keras/activations/softmax">tf.keras.activation.softmax</a>)</li>
<li>le nombre d'entrées est déduit automatiquement (nombre de neurones de la couche précédente)</li>
</ul>
</li>
</ul>
</li>
<li>3/ Une fois construit, le réseau doit être compilé (au sens de tensorflow) avec la méthdoe <code>compile</code> avec les arguments :<ul>
<li><code>loss='categorical_crossentropy'</code> : choix de la fonction d'erreur (cf <a href="https://www.tensorflow.org/api_docs/python/tf/keras/losses/categorical_crossentropy">tf.keras.categorical_crossentropy</a>)</li>
<li><code>optimizer='adam'</code> : choix de l'optimiseur Adam (cf page <a href="https://www.tensorflow.org/api_docs/python/tf/keras/optimizers/Adam">tf.keras.optimizers.Adam</a>)</li>
<li><code>metrics=['accuracy']</code> pour obtenir les données permettant de tracer les courbes de performance.</li>
</ul>
</li>
</ul></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">tensorflow.keras.models</span> <span class="kn">import</span> <span class="n">Sequential</span>
<span class="kn">from</span> <span class="nn">tensorflow.keras.layers</span> <span class="kn">import</span> <span class="n">Dense</span> 

<span class="n">nb_classe</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">tf</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>

<span class="c1"># les 5 lignes pour construire le réseau de neurones:</span>
<span class="n">model</span> <span class="o">=</span> 
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Avec la méthode <code>summary</code> de l'objet <code>model</code>, faire afficher la description du modèle : noter les valeurs des paramètres...</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Pourquoi y-a-t-il des <code>None</code> dans la colonne "Output Shape"  ?</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Retrouver le nombre total de paramètres avec une formule simple ...</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>La fonction <code>plot_model</code> permet de dessiner la structure du réseau (voir la page <a href="https://www.tensorflow.org/api_docs/python/tf/keras/utils/plot_model">tf.keras.utils.plot_model</a>).<br>
Faire tracer la structure du modèle en ajoutant l'option <code>show_shapes=True</code> à l'appel de <code>plot_model</code> :</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Remarque</em> : en utilisant l'argument nommé <code>name</code> dans la fonction <code>Dense</code>, on peut donner des noms personnalisés aux couches, qui apparaîtront dans les sorties de <code>summary</code> et de <code>plot_model</code>.</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Sauvegarde-de-l'&#233;tat-initial-du--r&#233;seau">Sauvegarde de l'&#233;tat initial du  r&#233;seau<a class="anchor-link" href="#Sauvegarde-de-l'&#233;tat-initial-du--r&#233;seau">&#182;</a></h3></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>On peut sauvegarder l'état initial des poids du réseau non-entraîné (valeurs aléatoires) avec la méthode <code>save_weights</code> de la classe <code>Sequential</code>. <br>
Ce sera utile plus loin pour remettre le réseau à son état initial avant de relancer d'autres entraînements :</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># vérifier que le dossier &#39;weights&#39; existe et sinon le créer:</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="s2">&quot;weights&quot;</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s2">&quot;weights&quot;</span><span class="p">)</span>

<span class="c1"># sauvegarde des poinds du réseau initial:</span>
<span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;model_initial&#39;</span>
<span class="n">model</span><span class="o">.</span><span class="n">save_weights</span><span class="p">(</span><span class="s1">&#39;weights/&#39;</span><span class="o">+</span><span class="n">key</span><span class="p">)</span>

<span class="c1"># afficher les fichiers créés:</span>
<span class="n">files</span><span class="o">=</span><span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;weights&quot;</span><span class="p">,</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s2">&quot;weights&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Remarque : la méthode <code>save_weights</code> utilise la partie <code>key</code> du chemin passé en argument pour préfixer les fichiers créés.<br>
Lors de la lecture ultérieure des poids du réseau avec la méthode <code>load_weights</code> de la classe <code>Sequential</code>, il suffira de donner la même information pour retrouver les bons fichiers.</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="4---Entra&#238;nement-du-r&#233;seau">4 - Entra&#238;nement du r&#233;seau<a class="anchor-link" href="#4---Entra&#238;nement-du-r&#233;seau">&#182;</a></h2></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Consulter au besoin la documentation de la méthode <code>fit</code> sur la page <a href="https://www.tensorflow.org/api_docs/python/tf/keras/Sequential">tf.keras.Sequential</a>.</p>
<p>Compléter la cellule ci-dessous pour entraîner le réseau avec la méthode <code>fit</code> de l'objet <code>model</code> en utilisant les arguments :</p>
<ul>
<li><code>x_train</code> : les 60000 images mises à plat et normalisées</li>
<li><code>y_train</code> : les 60000 labels encodés <em>one-hot</em>.</li>
<li><code>epochs=15</code> : faire 15 fois l'entraînement complet.</li>
<li><code>batch_size=128</code> : découper le jeu des données d'entrée (les 60000 images) en "lots" (<em>batch</em>) de taille <code>batch_size</code> (ici en lots de 128 images).<br>
La mise à jour des poids du réseau est faite au bout de <code>batch_size</code> échantillons d'entrée.<br>
La valeur de <code>batch_size</code> (par défaut : 32) est un paramètre qui influe sur la qualité de l'apprentissage mais aussi sur son empreinte mémoire : on peut essayer différentes (64, 128, 256 ...) et observer comment évolue la qualité de l'entraînement).</li>
</ul></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># au cas on on exécute plusieurs fois cette cellule, on peut ré-initialiser </span>
<span class="c1"># le réseau à son état initial si on veut comparer les entraînements...</span>
<span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;model_initial&#39;</span>
<span class="n">model</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="s1">&#39;weights/&#39;</span><span class="o">+</span><span class="n">key</span><span class="p">)</span>  

<span class="n">hist</span> <span class="o">=</span> <span class="o">...</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>L'objet <code>hist</code> retourné par la méthode <code>fit</code> possède un attribut <code>history</code> de type dictionnaire dont les clefs <code>'loss'</code> et <code>'accuracy'</code> contiennent l'évaluation de la perte et de de précision du réseau entraîné après chaque 'époque ' (<em>epoch</em>) :</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">hist</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">hist</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s1">&#39;loss&#39;</span><span class="p">]</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">hist</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">]</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Trac&#233;-des-courbes-loss-et-accuracy">Trac&#233; des courbes <code>loss</code> et <code>accuracy</code><a class="anchor-link" href="#Trac&#233;-des-courbes-loss-et-accuracy">&#182;</a></h3></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>La fonction <code>plot_loss_accuracy</code> du module <code>utils.tools</code> (présent dans le répertoire du notebook) permet de tracer les courbes "fonction d'erreur et de "précision" sur la base des données stockées dans <code>hist</code>.<br> Importer et utiliser la fonction<code>plot_loss_accuracy</code> pour faire tracer ces courbes :</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="&#192;-propos-de-la-reproductibilit&#233;-de-l'entra&#238;nement...">&#192; propos de la reproductibilit&#233; de l'entra&#238;nement...<a class="anchor-link" href="#&#192;-propos-de-la-reproductibilit&#233;-de-l'entra&#238;nement...">&#182;</a></h3></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>la reproductibilité parfaite d'un entraînement de réseau de neurones est difficile à atteindre avec tensorflow....</p>
<p>Observez les résultats des cellules suivantes :</p>
<p>Dans ce premier essai, le réseau est initialisé une fois, puis à chaque tour de boucle il est entraîné sur la base de son état au tour de boule précédent... <code>loss</code> et <code>accuracy</code> évoluent à chaque tour de boucle.<br>
$\leadsto$ c'est comme si on avait fait un <code>model.fit(x_train, y_train, epochs=10, batch_size=128)</code></p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># recharger l&#39;état initial du réseau:</span>
<span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;model1_initial&#39;</span>
<span class="n">model</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="s1">&#39;weights/&#39;</span><span class="o">+</span><span class="n">key</span><span class="p">)</span> 

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Dans la cellule suivante, on réinitialise bien l'état initial du réseau <strong>avant chaque lancement de <code>fit</code></strong> : c'est mieux, mais ce n'est pas encore parfait...</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="c1"># recharger l&#39;état initial du réseau:</span>
    <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;model1_initial&#39;</span>
    <span class="n">model</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="s1">&#39;weights/&#39;</span><span class="o">+</span><span class="n">key</span><span class="p">)</span> 

    <span class="n">hist</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Et dans cet essai, on ré-initialise la graine tensorflow avec <code>tf.random.set_seed(SEED)</code> avant chaque invocation de <code>fit</code> : ce n'est toujours pas exactement les mêmes valeurs <code>loss</code> et <code>accuracy</code> que l'on observe, mais c'en est très proche...</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="c1"># recharger l&#39;état initial du réseau:</span>
    <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;model1_initial&#39;</span>
    <span class="n">model</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="s1">&#39;weights/&#39;</span><span class="o">+</span><span class="n">key</span><span class="p">)</span> 
    <span class="n">tf</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="n">SEED</span><span class="p">)</span>
    
    <span class="n">hist</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="5---Entra&#238;nement-du-r&#233;seau-avec-test-&#224;-chaque-epoch">5 - Entra&#238;nement du r&#233;seau avec test &#224; chaque <code>epoch</code><a class="anchor-link" href="#5---Entra&#238;nement-du-r&#233;seau-avec-test-&#224;-chaque-epoch">&#182;</a></h2></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Pour avoir un indicateur réaliste de la qualité du réseau entraîné on peut tester à chaque <code>epoch</code> la précison des prédictions du réseau entraîné en utilisant les données de test : il suffit de passer l'agument <code>validation_data</code> à la méthode <code>fit</code>, en lui affectant le tuple des données de test <code>(x_test, y_test)</code></p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># recharger l&#39;état initial du réseau:</span>
<span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;model1_initial&#39;</span>
<span class="n">model</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="s1">&#39;weights/&#39;</span><span class="o">+</span><span class="n">key</span><span class="p">)</span> 
<span class="n">tf</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="n">SEED</span><span class="p">)</span>

<span class="n">hist</span> <span class="o">=</span> <span class="o">...</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>On a cette fois dans <code>hist.history</code> non seulement les clefs <code>loss</code> et <code>accuracy</code> mais aussi <code>val_loss</code> et <code>val_accuracy</code> calculés avec les données de test :</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">hist</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Faire afficher ces courbes avec la fonction <code>plot_loss_accuracy</code> :</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>On voit que la précision calculée avec les données de test tend vers une limite voisine de 98%. <br>
On pourrait penser qu'augmenter la valeur de <code>epochs</code> permet d'améliorer la précision du réseau... mais on court le risque de sur-entraînner le réseau (<em>over-fit</em>).</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Arr&#234;ter-automatiquement-l'entra&#238;nement-avant-over-fit">Arr&#234;ter automatiquement l'entra&#238;nement avant <em>over-fit</em><a class="anchor-link" href="#Arr&#234;ter-automatiquement-l'entra&#238;nement-avant-over-fit">&#182;</a></h3><p>Keras propose des outils pour arrêter automatiquement l'apprentissage en surveillant par exemple la croissance de la précision d'une <code>epoch</code> à l'autre. On peut ainsi définir une liste de fonctions <em>callback</em> que l'on peut passer en argument à la fonction <code>fit</code> avec l'agument nommé  <code>callbacks</code> :</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">tensorflow.keras.callbacks</span> <span class="kn">import</span> <span class="n">EarlyStopping</span>

<span class="n">callbacks_list</span> <span class="o">=</span> <span class="p">[</span> 
    <span class="n">EarlyStopping</span><span class="p">(</span><span class="n">monitor</span><span class="o">=</span><span class="s1">&#39;val_accuracy&#39;</span><span class="p">,</span>  <span class="c1"># la grandeur à surveiller</span>
                  <span class="n">patience</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>              <span class="c1"># accepter que &#39;val_accuracy&#39; diminue 2 fois de suite</span>
                  <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="p">]</span>

<span class="c1"># recharger l&#39;état initial du réseau:</span>
<span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;model1_initial&#39;</span>
<span class="n">model</span><span class="o">.</span><span class="n">load_weights</span><span class="p">(</span><span class="s1">&#39;weights/&#39;</span><span class="o">+</span><span class="n">key</span><span class="p">)</span> 
<span class="n">tf</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="n">SEED</span><span class="p">)</span>

<span class="n">hist</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Tracer les courbes <code>loss</code> et <code>accuracy</code> :</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Sauvegarder-les-poids-du--r&#233;seau-entra&#238;n&#233;">Sauvegarder les poids du  r&#233;seau entra&#238;n&#233;<a class="anchor-link" href="#Sauvegarder-les-poids-du--r&#233;seau-entra&#238;n&#233;">&#182;</a></h3></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>La méthode <code>save_weights</code> de la classe <code>Sequential</code>permet d'enregistrer les <strong>poids</strong> du réseau entraïné dans un fichier :</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="c1"># vérifier que le dossier &#39;weights&#39; existe et sinon le créer:</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s2">&quot;weights&quot;</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s2">&quot;weights&quot;</span><span class="p">)</span>

<span class="c1"># sauvegarde des poids du réseau entrainé:</span>
<span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;model1_trained&#39;</span>
<span class="n">model</span><span class="o">.</span><span class="n">save_weights</span><span class="p">(</span><span class="s1">&#39;weights&#39;</span><span class="o">+</span><span class="n">key</span><span class="p">)</span>

<span class="c1"># afficher les fichiers créés:</span>
<span class="n">files</span><span class="o">=</span><span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;weights&quot;</span><span class="p">,</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s2">&quot;weights&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Sauvegarder-la-structure-du-r&#233;seau-et-ses-poids">Sauvegarder la structure du r&#233;seau et ses poids<a class="anchor-link" href="#Sauvegarder-la-structure-du-r&#233;seau-et-ses-poids">&#182;</a></h3></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>La méthode <code>save</code> de la classe <code>Sequential</code> permet d'enregistrer <strong>toute la structure et les poids</strong> du réseau entraïné dans un fichier.<br />
Ceci permet de recréer plus tard <em>from scratch</em> le réseau entrainé pour passer en phase exploitation du réseau par exemple, en utilisant la fonction<code>tf.keras.models.load_model</code> :</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="c1"># vérifier que le dossier &#39;weights&#39; existe et sinon le créer:</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s2">&quot;models&quot;</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s2">&quot;models&quot;</span><span class="p">)</span>

<span class="c1"># sauvegarder structure réseau + poids :</span>
<span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;model1&#39;</span>
<span class="n">model</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;models/&#39;</span><span class="o">+</span><span class="n">key</span><span class="p">)</span> 

<span class="c1"># afficher les fichiers créés:</span>
<span class="n">files</span><span class="o">=</span><span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;models&quot;</span><span class="p">,</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s2">&quot;models&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="6/-Exploitation-du-r&#233;seau-avec-le-jeu-de-test">6/ Exploitation du r&#233;seau avec le jeu de test<a class="anchor-link" href="#6/-Exploitation-du-r&#233;seau-avec-le-jeu-de-test">&#182;</a></h2></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>La méthode <code>predict</code> de l'objet <code>model</code> permet de calculer la prédiction du réseau pour une ou plusieurs entrées (voir la méthode <code>predict</code>dans la page <a href="https://www.tensorflow.org/api_docs/python/tf/keras/Sequential">tf.keras.Sequential</a>).</p>
<p>La cellule ci-dessous montre la mise en oeuvre de la méthode <code>predict</code>, et comment exploiter la représentation  <em>one-hot</em> renvoyée par <code>fit</code> en utilisant la méthode <code>argmax</code> des tableaux de numpy :</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">100</span>   <span class="c1"># numéro image de test</span>
<span class="n">rep</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># Attention: x doit être un tableau de matrices...</span>
                                   <span class="c1"># =&gt; x[i] ne convient pas !</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sortie du réseau pour l&#39;image de rang </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> :</span><span class="se">\n</span><span class="si">{</span><span class="n">rep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># limiter l&#39;affichage des composantes des tableaux numpy à 1 chiffre :    </span>
<span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">printoptions</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;float&#39;</span><span class="p">:</span><span class="s1">&#39;</span><span class="si">{:.1f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">}):</span>    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">sortie réseau arrondie à 1 chiffre : </span><span class="si">{</span><span class="n">rep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;rep[0].argmax() donne : </span><span class="si">{</span><span class="n">rep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">La bonne réponse est </span><span class="si">{</span><span class="n">lab_test</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> soit en &#39;hot-one&#39; : </span><span class="si">{</span><span class="n">y_test</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">plot_images</span><span class="p">(</span><span class="n">im_test</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Utilit&#233;-de-la-m&#233;thode-numpy-ndarray.argmax-pour-d&#233;coder-le-tableau-de-vecteurs-one-hot-renvoy&#233;-par-la-m&#233;thode-predict">Utilit&#233; de la m&#233;thode numpy <code>ndarray.argmax</code> pour d&#233;coder le tableau de vecteurs <em>one-hot</em> renvoy&#233; par la m&#233;thode <code>predict</code><a class="anchor-link" href="#Utilit&#233;-de-la-m&#233;thode-numpy-ndarray.argmax-pour-d&#233;coder-le-tableau-de-vecteurs-one-hot-renvoy&#233;-par-la-m&#233;thode-predict">&#182;</a></h4></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Quand on calcule la prédiction du réseau <code>model</code> avec les données de test par exemple, on obtient un résultat qui est un tableau de vecteurs codés <em>one-hot</em>, comme le détaille la cellue suivante :</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_test</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;forme du tableau &#39;results&#39;:&quot;</span><span class="p">,</span> <span class="n">results</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;allure des vecteurs du tableau &#39;result&#39;, par exemple :&quot;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">printoptions</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;float&#39;</span><span class="p">:</span><span class="s1">&#39;</span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">}):</span> 
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;results[0]  :&quot;</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;results[-1] :&quot;</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>En écrivant <code>results.argmax(axe=-1)</code>, on obtient le tableau des <code>argmax</code> de chaque vecteur -&gt; c'est directement le tableau des chiffres reconnus par le réseau :</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">chiffres_reconnus</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;chiffres_reconnus -&gt; shape:&quot;</span><span class="p">,</span> <span class="n">chiffres_reconnus</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;, dtype:&quot;</span><span class="p">,</span> <span class="n">chiffres_reconnus</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;contenu de chiffres_reconnus : </span><span class="si">{</span><span class="n">chiffres_reconnus</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>En déduire le taux de réussite du réseau entrainé en calculant la prédiction du réseau sur les données de test <code>x_test</code> et en les comparant aux labels <code>lab_test</code> :</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Afficher-la-matrice-de-confusion">Afficher la matrice de confusion<a class="anchor-link" href="#Afficher-la-matrice-de-confusion">&#182;</a></h3></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>La cellule suivante définie la fonction <code>show_cm_mnist</code> qui affiche la <strong>matrice de confusion</strong>.</p>
<p>La matrice de confusion permet de visualiser :</p>
<ul>
<li>sur la diagonale : les bonnes réponses du réseau, avec dans chaque case le nombre de bonnes réponses</li>
<li>hors diagonale : les erreurs du réseau, avec dans chaque case la fréquence d'apparition de l'erreur.</li>
</ul></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">seaborn</span> <span class="kn">import</span> <span class="n">heatmap</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">confusion_matrix</span>

<span class="k">def</span> <span class="nf">show_cm_mnist</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">classes</span><span class="p">):</span>
    <span class="c1"># target : the actual labels</span>
    <span class="c1"># results : the labels computed by the trained network (one-hot format)</span>
    <span class="c1"># classes : list of possible label values</span>
    <span class="n">predicted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># tableau d&#39;entiers entre 0 et 9 </span>
    <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">predicted</span><span class="p">)</span>
    <span class="n">df_cm</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">classes</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">classes</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">df_cm</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">);</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Faire afficher la matrice de confusion en lui passant les labels attendus <code>lab_test</code> et les labels calculés par le model :</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="D/-Bonus">D/ Bonus<a class="anchor-link" href="#D/-Bonus">&#182;</a></h1></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="R&#233;seau-profond-:-augmenter-le-nombre-de-couches-cach&#233;es">R&#233;seau profond : augmenter le nombre de couches cach&#233;es<a class="anchor-link" href="#R&#233;seau-profond-:-augmenter-le-nombre-de-couches-cach&#233;es">&#182;</a></h2><p>On peut essayer de construire un réseau avec plus de couches. Par exemple :</p>
<ul>
<li>couche d'entrée avec les 784 pixels</li>
<li>couche cachée 1 : 784 neurones, fonction d'activation `relu</li>
<li>couche cachée 2 : 200 neurones, fonction d'activation <code>relu</code>    </li>
<li>couche cachée 3 : 100 neurones, fonction d'activation <code>relu</code>   </li>
<li>couche de sortie : 10 neurone, fonction d'activation <code>softmax</code>.</li>
</ul></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Écrire une fonction paramétrée <code>build_nn</code> selon ces spécifications :</p>
<ul>
<li>Construire un réseau de neurones dense dédié à la reconnaissance des chiffres MNIST avec un nombre de neurones par couche paramétré, sauf pour la dernière couche dont le nombre de neurones est fixé par <code>nb_classe</code>.</li>
<li>Entraîner le réseau avec test à la fin de chaque <code>epoch</code> et arrêt automatique basé sur la surveillance de <code>val_accuracy</code> .</li>
<li>Afficher les courbes 'Model Loss' et 'Model accuracy' du réseau entraîné.</li>
<li>Afficher la matrice de confusion.</li>
</ul>
<p>Par exemple, pour créer, entraîner et tester le réseau profond suggéré ci-dessus, on pourrait écrire :<br></p>

<pre><code>data = (x_train, y_train, x_test, y_test)
tf.random.set_seed(SEED)
my_model1 = build_mn((784, 200, 100), nb_pixel, nb_classe, data, batch_size=128)</code></pre></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># définition de la fonction build_nn</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># utilisation de build_nn :</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Quel est l'impact de l'augmentation du nombre de couches du réseau ?<br></p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Faire-reconna&#238;tre-des-images-originales-&#224;-un-r&#233;seau-entra&#238;n&#233;-avec-les-images-MNIST">Faire reconna&#238;tre des images originales &#224; un r&#233;seau entra&#238;n&#233; avec les images MNIST<a class="anchor-link" href="#Faire-reconna&#238;tre-des-images-originales-&#224;-un-r&#233;seau-entra&#238;n&#233;-avec-les-images-MNIST">&#182;</a></h2></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Plusieurs possibilités :</p>
<ul>
<li>utiliser des images crées pour l'occasion... </li>
<li>utiliser les images toutes prêtes du répertoire <code>chiffres</code>.</li>
</ul>
<p>Si tu crées tes propres images de chiffres écrits à la main, il faut :</p>
<ul>
<li>les mettre au format MNIST (20x28 pixels en ton de gris, chiffre centré dans l'image) </li>
<li>les placer dans un répertoire spécifique ,</li>
<li>affecter ce nom de ce répertoire à <code>images_dir</code> dans la cellule ci-dessous :</li>
</ul></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># changer le nom du répertoire au besoin :</span>
<span class="n">images_dir</span> <span class="o">=</span> <span class="s2">&quot;chiffres&quot;</span>

<span class="n">images</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">images_dir</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.png&quot;</span><span class="p">)]</span>
<span class="n">images</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Images du dossier &lt;</span><span class="si">{</span><span class="n">images_dir</span><span class="si">}</span><span class="s2">&gt; à reconnaître :&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Lecture-des-fichiers-image-avec-openCV">Lecture des fichiers image avec openCV<a class="anchor-link" href="#Lecture-des-fichiers-image-avec-openCV">&#182;</a></h3></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Les images doivent être convertie en image en ton de gris de 28 x 28 pixels pour pouvoir être traitées par le réseau entraîné sur les images MNIST.</p>
<p>Plusieurs fonctions du module OpenCV pourront être utilisées :</p>
<ul>
<li><code>cv2.imread(file_name)</code> : pour lire un fichier image aux formats standards (PNG, JPG,...)</li>
<li><code>cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</code> : pour convertir le tableau <code>img</code> renvoyé par <code>cv2.imread</code> en tons de gris</li>
<li><code>cv2.resize</code> : pour retailler l'image.</li>
</ul>
<p>La cellule ci-dessous montre un exemple de lecture et traitement avec OpenCV des images du dossier <code>chiffres</code> qui sont déjà au format 28 x 28 pixe :</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">cv2</span>
<span class="n">my_images</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">image_path</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span>                    <span class="c1"># lecture fichier image</span>
    <span class="n">img_gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span> <span class="c1"># conversion en tons de gris</span>
    <span class="n">my_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_gray</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Visualisation des images lues :</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">plot_images</span><span class="p">(</span><span class="n">my_images</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Inversion des images pour avoir des chiffres doivent être en blanc sur fond noir :</p></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">my_images</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span> <span class="o">-</span> <span class="n">im</span> <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">my_images</span><span class="p">]</span>
<span class="n">plot_images</span><span class="p">(</span><span class="n">my_images</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>On peut maintenant :</p>
<ul>
<li>transformer des matrices 28x28 en vecteurs de float normalisés,</li>
<li>calculer le prédiction du réseau entaîné de votre choix (<code>model</code> ou autre...) avec les images perso en entrée,</li>
<li>faire afficher la précision obtenue et la matric de confusion.</li>
</ul></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span>
</pre></div></div></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Que suggèerent les  résultats ?</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="La-suite....">La suite....<a class="anchor-link" href="#La-suite....">&#182;</a></h1><p>Pour aller au-delà des 98% de reconnaissance des chiffres MNIST et une meilleure reconnaissance des 'images perso', il faut passer à une architecture de réseau plus adaptée au traitement des images : les réseaux <strong>convolutionnels</strong>, traités dans le notebook <code>TP3_MNIST_convol.ipynb</code>.</p></div></div></div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Autres-ressources-int&#233;ressantes...-des-vid&#233;os-:">Autres ressources int&#233;ressantes... des vid&#233;os :<a class="anchor-link" href="#Autres-ressources-int&#233;ressantes...-des-vid&#233;os-:">&#182;</a></h1></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%%</span><span class="k">HTML</span>
&lt;iframe src=&quot;https://www.youtube.com/embed/trWrEWfhTVg&quot; width=&quot;800&quot; height=&quot;450&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">




<div class="output_html rendered_html output_subarea ">
<iframe src="https://www.youtube.com/embed/trWrEWfhTVg" width="800" height="450" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div></div></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%%</span><span class="k">HTML</span>
&lt;iframe src=&quot;https://www.youtube.com/embed/aircAruvnKk&quot; width=&quot;800&quot; height=&quot;450&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">




<div class="output_html rendered_html output_subarea ">
<iframe src="https://www.youtube.com/embed/aircAruvnKk" width="800" height="450" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div></div></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%%</span><span class="k">HTML</span>
&lt;iframe src=&quot;https://www.youtube.com/embed/IHZwWFHWa-w&quot; width=&quot;800&quot; height=&quot;450&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">




<div class="output_html rendered_html output_subarea ">
<iframe src="https://www.youtube.com/embed/IHZwWFHWa-w" width="800" height="450" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div></div></div></div></div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell"
  
>
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%%</span><span class="k">HTML</span>
&lt;iframe src=&quot;https://www.youtube.com/embed/Ilg3gGewQ5U&quot; width=&quot;800&quot; height=&quot;450&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;
</pre></div></div></div></div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">




<div class="output_html rendered_html output_subarea ">
<iframe src="https://www.youtube.com/embed/Ilg3gGewQ5U" width="800" height="450" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div></div></div></div></div>

